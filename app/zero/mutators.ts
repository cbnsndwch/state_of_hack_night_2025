/**
 * Zero Sync Mutators
 *
 * Defines mutations using Zero's `defineMutators` / `defineMutator` API.
 * Mutators run optimistically on the client (against local storage) and then
 * are sent to zero-cache, which calls our /api/zero/mutate endpoint to
 * execute them against Postgres.
 *
 * Key rules (from Zero docs):
 * - Do NOT generate IDs inside mutators -- they run multiple times.
 *   Always pass client-generated IDs via args.
 * - Use `Date.now()` for timestamps (schema columns are type 'number').
 * - Use flat objects for CRUD:
 *     tx.mutate.table.insert({ id, field1, field2 })
 *     tx.mutate.table.update({ id, field1 })      // PK + changed fields
 *     tx.mutate.table.delete({ id })
 * - tx.run(zql...) reads data transactionally within mutators.
 * - Auth checks use `tx.location === 'server'` to only run on the server,
 *   keeping optimistic client-side mutations fast.
 */

import { defineMutators, defineMutator } from '@rocicorp/zero';
import { z } from 'zod';
import { zql } from './schema';

/** Context shape set by the Zero constructor (client) and mutate endpoint (server) */
type MutationContext = {
    userId: string;
    role?: string;
};

/**
 * All application mutators, registered with `defineMutators`.
 *
 * Usage on the client:
 *   zero.mutate(mutators.profiles.update({ id, bio: 'new bio' }))
 *
 * Registration:
 *   new Zero({ ..., mutators })
 */
export const mutators = defineMutators({
    profiles: {
        /**
         * Update a user's profile.
         * All fields except `id` are optional -- pass only the fields to change.
         */
        update: defineMutator(
            z.object({
                id: z.string(),
                bio: z.string().optional(),
                lumaAttendeeId: z.string().optional(),
                skills: z.array(z.string()).optional(),
                githubUsername: z.string().optional(),
                twitterHandle: z.string().optional(),
                websiteUrl: z.string().optional(),
                linkedinUrl: z.string().optional(),
                role: z.string().optional(),
                seekingFunding: z.boolean().optional(),
                openToMentoring: z.boolean().optional(),
                lookingForCofounder: z.boolean().optional(),
                wantProductFeedback: z.boolean().optional(),
                seekingAcceleratorIntros: z.boolean().optional(),
                wantToGiveBack: z.boolean().optional(),
                specialties: z.array(z.string()).optional(),
                interestedExperiences: z.array(z.string()).optional(),
                onboardingDismissed: z.boolean().optional()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization: verify profile ownership
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const profile = await tx.run(
                        zql.profiles.where('id', args.id).one()
                    );
                    if (!profile) {
                        throw new Error('Profile not found');
                    }
                    if (profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only update your own profile'
                        );
                    }
                }

                const { id, ...updates } = args;

                await tx.mutate.profiles.update({
                    id,
                    ...updates,
                    updatedAt: Date.now()
                });
            }
        )
    },

    projects: {
        /**
         * Create a new project.
         * The `id` must be generated by the caller (e.g. `crypto.randomUUID()`).
         */
        create: defineMutator(
            z.object({
                id: z.string(),
                memberId: z.string(),
                title: z.string().min(1, 'Title is required'),
                description: z.string().optional(),
                tags: z.array(z.string()).optional(),
                imageUrls: z.array(z.string()).optional(),
                githubUrl: z.string().optional(),
                publicUrl: z.string().optional()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization: verify profile ownership
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const profile = await tx.run(
                        zql.profiles.where('id', args.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only create projects for yourself'
                        );
                    }
                }

                await tx.mutate.projects.insert({
                    id: args.id,
                    memberId: args.memberId,
                    title: args.title,
                    description: args.description,
                    tags: args.tags,
                    imageUrls: args.imageUrls,
                    githubUrl: args.githubUrl,
                    publicUrl: args.publicUrl,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                });
            }
        ),

        /**
         * Update an existing project.
         */
        update: defineMutator(
            z.object({
                id: z.string(),
                title: z.string().min(1).optional(),
                description: z.string().optional(),
                tags: z.array(z.string()).optional(),
                imageUrls: z.array(z.string()).optional(),
                githubUrl: z.string().optional(),
                publicUrl: z.string().optional()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization: verify project ownership
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const project = await tx.run(
                        zql.projects.where('id', args.id).one()
                    );
                    if (!project) {
                        throw new Error('Project not found');
                    }
                    const profile = await tx.run(
                        zql.profiles.where('id', project.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only update your own projects'
                        );
                    }
                }

                const { id, ...updates } = args;

                await tx.mutate.projects.update({
                    id,
                    ...updates,
                    updatedAt: Date.now()
                });
            }
        ),

        /**
         * Delete a project.
         */
        delete: defineMutator(
            z.object({
                id: z.string()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization: verify project ownership
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const project = await tx.run(
                        zql.projects.where('id', args.id).one()
                    );
                    if (!project) {
                        throw new Error('Project not found');
                    }
                    const profile = await tx.run(
                        zql.profiles.where('id', project.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only delete your own projects'
                        );
                    }
                }

                await tx.mutate.projects.delete({
                    id: args.id
                });
            }
        )
    },

    attendance: {
        /**
         * Check in to an event.
         * The `id` must be generated by the caller.
         */
        checkIn: defineMutator(
            z.object({
                id: z.string(),
                memberId: z.string(),
                lumaEventId: z.string()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const profile = await tx.run(
                        zql.profiles.where('id', args.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only check in for yourself'
                        );
                    }
                }

                // Duplicate check -- runs on both client (if cached) and server
                const existing = await tx.run(
                    zql.attendance
                        .where(q =>
                            q.and(
                                q.cmp('memberId', '=', args.memberId),
                                q.cmp('lumaEventId', '=', args.lumaEventId)
                            )
                        )
                        .one()
                );

                if (existing) {
                    throw new Error('Already checked in to this event');
                }

                await tx.mutate.attendance.insert({
                    id: args.id,
                    memberId: args.memberId,
                    lumaEventId: args.lumaEventId,
                    createdAt: Date.now()
                });
            }
        )
    },

    surveyResponses: {
        /**
         * Submit or update a survey response.
         * Pass `id` for new responses (generated by caller).
         * If a response already exists for this member+survey, it is updated.
         */
        submit: defineMutator(
            z.object({
                id: z.string(),
                surveyId: z.string(),
                memberId: z.string(),
                responses: z.record(z.any()),
                isComplete: z.boolean()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const profile = await tx.run(
                        zql.profiles.where('id', args.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only submit survey responses for yourself'
                        );
                    }
                }

                // Check if already submitted (upsert logic)
                const existing = await tx.run(
                    zql.surveyResponses
                        .where(q =>
                            q.and(
                                q.cmp('memberId', '=', args.memberId),
                                q.cmp('surveyId', '=', args.surveyId)
                            )
                        )
                        .one()
                );

                if (existing) {
                    // Update existing response
                    await tx.mutate.surveyResponses.update({
                        id: existing.id,
                        responses: args.responses,
                        isComplete: args.isComplete,
                        submittedAt: args.isComplete ? Date.now() : null,
                        updatedAt: Date.now()
                    });
                } else {
                    // Create new response
                    await tx.mutate.surveyResponses.insert({
                        id: args.id,
                        surveyId: args.surveyId,
                        memberId: args.memberId,
                        responses: args.responses,
                        isComplete: args.isComplete,
                        submittedAt: args.isComplete ? Date.now() : null,
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    });
                }
            }
        )
    },

    demoSlots: {
        /**
         * Request a demo slot.
         * The `id` must be generated by the caller.
         */
        request: defineMutator(
            z.object({
                id: z.string(),
                memberId: z.string(),
                eventId: z.string(),
                title: z.string().min(1, 'Title is required'),
                description: z.string().optional(),
                requestedTime: z.string().optional(),
                durationMinutes: z.number().optional()
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization
                if (tx.location === 'server') {
                    const { userId } = ctx as MutationContext;
                    const profile = await tx.run(
                        zql.profiles.where('id', args.memberId).one()
                    );
                    if (!profile || profile.clerkUserId !== userId) {
                        throw new Error(
                            'Unauthorized: You can only request demo slots for yourself'
                        );
                    }
                }

                await tx.mutate.demoSlots.insert({
                    id: args.id,
                    memberId: args.memberId,
                    eventId: args.eventId,
                    title: args.title,
                    description: args.description,
                    requestedTime: args.requestedTime,
                    durationMinutes: args.durationMinutes ?? 5,
                    status: 'pending',
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                });
            }
        ),

        /**
         * Update demo slot status (owner or admin).
         */
        updateStatus: defineMutator(
            z.object({
                id: z.string(),
                status: z.enum(['pending', 'confirmed', 'canceled'])
            }),
            async ({ args, tx, ctx }) => {
                // Server-only authorization (includes admin check)
                if (tx.location === 'server') {
                    const { userId, role } = ctx as MutationContext;
                    const slot = await tx.run(
                        zql.demoSlots.where('id', args.id).one()
                    );
                    if (!slot) {
                        throw new Error('Demo slot not found');
                    }
                    const profile = await tx.run(
                        zql.profiles.where('id', slot.memberId).one()
                    );
                    if (
                        !profile ||
                        (profile.clerkUserId !== userId && role !== 'admin')
                    ) {
                        throw new Error('Unauthorized');
                    }
                }

                await tx.mutate.demoSlots.update({
                    id: args.id,
                    status: args.status,
                    updatedAt: Date.now()
                });
            }
        )
    }
});

// ---------------------------------------------------------------------------
// Legacy type exports for backward compatibility
// ---------------------------------------------------------------------------

export type CreateProfileInput = {
    clerkUserId: string;
    lumaEmail: string;
    lumaAttendeeId?: string;
    githubUsername?: string;
    bio?: string;
    skills?: string[];
};

export type UpdateProfileInput = {
    id: string;
    bio?: string;
    skills?: string[];
    githubUsername?: string;
    twitterHandle?: string;
    websiteUrl?: string;
    linkedinUrl?: string;
    role?: string;
    seekingFunding?: boolean;
    openToMentoring?: boolean;
    lookingForCofounder?: boolean;
    wantProductFeedback?: boolean;
    seekingAcceleratorIntros?: boolean;
    wantToGiveBack?: boolean;
    specialties?: string[];
    interestedExperiences?: string[];
    onboardingDismissed?: boolean;
};

export type CreateProjectInput = {
    id: string;
    memberId: string;
    title: string;
    description?: string;
    tags?: string[];
    imageUrls?: string[];
    githubUrl?: string;
    publicUrl?: string;
};

export type UpdateProjectInput = {
    id: string;
    title?: string;
    description?: string;
    tags?: string[];
    imageUrls?: string[];
    githubUrl?: string;
    publicUrl?: string;
};

export type CheckInInput = {
    id: string;
    memberId: string;
    lumaEventId: string;
};

export type SubmitSurveyResponseInput = {
    id: string;
    surveyId: string;
    memberId: string;
    responses: Record<string, unknown>;
    isComplete: boolean;
};

export type RequestDemoSlotInput = {
    id: string;
    memberId: string;
    eventId: string;
    title: string;
    description?: string;
    requestedTime?: string;
    durationMinutes?: number;
};

export type UpdateDemoSlotStatusInput = {
    id: string;
    status: 'pending' | 'confirmed' | 'canceled';
};

export type MutationSuccess<T = Record<string, unknown>> = {
    success: true;
    data?: T;
};

export type MutationError = {
    success: false;
    error: string;
};

export type MutationResult<T = Record<string, unknown>> =
    | MutationSuccess<T>
    | MutationError;
